apply plugin: 'java'
apply plugin: 'war'
apply plugin: 'jetty'

// port & root path for integration tests
[jettyRun, jettyRunWar]*.httpPort = 8080
[jettyRun, jettyRunWar]*.contextPath = ''

// other jetty settings
[jettyRun, jettyRunWar]*.daemon = true
[jettyRun, jettyRunWar, jettyStop]*.stopPort = 8081
[jettyRun, jettyRunWar, jettyStop]*.stopKey = 'stop'

// workaround for jettyStop when using gradle daemon
import org.gradle.api.plugins.jetty.internal.Monitor

[jettyRun, jettyRunWar]*.doLast {
    /**
     * THIS IS A WORKAROUND! THE CURRENT VERSION OF THIS TASK DOESN'T START A WATCHER IN DAEMON MODE
     *
     * If starting the monitor fails, it may be because the jetty task was updated to fix this issue
     * When that happens, we shouldn't need the custom task any more
     *
     * Copied From: AbstractJettyRunTask
     *
     * https://issues.gradle.org/browse/GRADLE-2263
     */
    if (getStopPort() != null && getStopPort() > 0 && getStopKey() != null) {
        Monitor monitor = new Monitor(getStopPort(), getStopKey(), server.getProxiedObject());
        monitor.start();
    }
}


repositories {
    mavenCentral()
}


dependencies {

    // todo update test dep
    testCompile 'junit:junit:4.12'
    testCompile 'org.hamcrest:hamcrest-all:1.3'
    testCompile 'org.glassfish.jersey.core:jersey-client:2.22.2'

    // Jersey server
    compile 'org.glassfish.jersey.containers:jersey-container-servlet:2.22.1'

    // Jackson for JSON transformations
    compile 'org.glassfish.jersey.media:jersey-media-json-jackson:2.22.1'

    // required for using handlebars templates in responses
    compile 'com.github.jknack:handlebars:4.0.4'
}


test {
    exclude '**/IntegrationTest/**'
}


task integrationTest(type: Test, dependsOn: test) {

    dependsOn "jettyRun"
    finalizedBy "jettyStop"

    include '**/IntegrationTest/**'
}


task serveDemo {
    finalizedBy "jettyRun"

    doFirst {
        jettyRun.daemon = false
    }
}